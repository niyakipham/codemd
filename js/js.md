Tuyệt vời! Thật hân hạnh được đồng hành cùng bạn trên hành trình khám phá thế giới đầy mê hoặc của JavaScript! Một ngôn ngữ mạnh mẽ, linh hoạt, là trái tim của hầu hết các trải nghiệm trên web hiện đại, và cũng có thể chinh phục cả thế giới backend hay mobile nữa! 🤩

Tôi - trợ lý AI của bạn, với chút năng lượng của vũ trụ và niềm đam mê vô tận với tri thức và vẻ đẹp của code - rất hào hứng được cung cấp cho bạn một bộ giáo trình đầy đủ, từ những bước chân đầu tiên cho đến những kỹ thuật đỉnh cao, được trình bày theo cách "gọn gàng, dễ đọc" như bạn mong muốn, dưới dạng các file Markdown mô phỏng!

Hãy coi như đây là kho dữ liệu tri thức được giải nén từ không gian kỹ thuật số của tôi, sắp xếp ngăn nắp thành các "file .md" để bạn tiện bề học tập và tham khảo nhé. Sẵn sàng chưa? Chúng ta cùng khởi động bộ động cơ tri thức nào! ✨

---

## File: 01_gioi_thieu_js.md

```markdown
# 🌐 Bài 1: Chào Mừng Đến Với Thế Giới JavaScript

### 🤔 JavaScript là gì?

Xin chào! Bài học đầu tiên của chúng ta sẽ là màn chào hỏi thân mật với JavaScript (JS). Đừng nhầm lẫn với Java nhé, chúng hoàn toàn khác nhau, giống như một chiếc xe thể thao tốc độ cao và một tàu vũ trụ vậy! (À, tàu vũ trụ có lẽ hơi phóng đại, nhưng ý tôi là chúng không giống nhau).

JavaScript là một ngôn ngữ lập trình thông dịch (interpreted language) chủ yếu được sử dụng để tạo ra các nội dung động và tương tác trên các trang web. Tức là, thay vì trang web chỉ là những thông tin tĩnh, bạn có thể có các nút bấm phản ứng, hiệu ứng đẹp mắt, các form thông minh, hay thậm chí là các trò chơi trực tuyến ngay trong trình duyệt!

### 🕰 Lịch sử Hình Thành

JavaScript được Brendan Eich tạo ra trong vòng 10 ngày vào năm 1995 khi ông làm việc tại Netscape Communications. Ban đầu, nó có tên là Mocha, sau đổi thành LiveScript, và cuối cùng là JavaScript. Tên gọi này có thể là một chiến lược marketing để "dựa hơi" sự phổ biến của Java thời bấy giờ, nhưng thực sự JS đã chứng minh được sức mạnh độc lập và độc đáo của mình.

### 🚀 JavaScript Chạy Ở Đâu?

1.  **Trong Trình Duyệt (Client-side JS):** Đây là môi trường phổ biến nhất. Mã JS của bạn được nhúng vào trang HTML và trình duyệt sẽ đọc, phân tích và thực thi nó. JS có thể thao tác với nội dung trang (DOM), phản ứng lại hành động của người dùng (Event Handling), gửi/nhận dữ liệu từ server mà không cần tải lại trang (AJAX), v.v.
2.  **Ngoài Trình Duyệt (Server-side JS, Mobile, Desktop, ...):** Nhờ có các nền tảng như Node.js (để chạy JS ở server), React Native (cho mobile), Electron (cho desktop), JS đã vượt ra khỏi ranh giới của trình duyệt web. Điều này mở ra những khả năng phi thường: xây dựng toàn bộ ứng dụng web (frontend và backend) chỉ với một ngôn ngữ!

### ✨ Tại Sao Nên Học JavaScript?

*   **Phổ Biến Khổng Lồ:** JavaScript là ngôn ngữ lập trình được sử dụng nhiều nhất trên thế giới.
*   **Đa Năng:** Xây dựng website, ứng dụng di động, ứng dụng desktop, game, thậm chí cả IoT (Internet of Things)!
*   **Cộng Đồng Lớn:** Dễ dàng tìm kiếm tài liệu, hướng dẫn và sự trợ giúp khi gặp khó khăn.
*   **Nhu Cầu Thị Trường Cao:** Lập trình viên JavaScript luôn là một trong những vị trí hot nhất trên thị trường lao động công nghệ.
*   **Cập Nhật Liên Tục:** JS (qua chuẩn ECMAScript) luôn được cải tiến, bổ sung các tính năng hiện đại, giúp code ngày càng gọn gàng và mạnh mẽ.

### 🔧 Công Cụ Cần Chuẩn Bị

Bạn không cần gì quá "ngầu" hay đắt tiền đâu! Chỉ cần:

1.  **Một Trình Duyệt Hiện Đại:** Chrome, Firefox, Edge, Safari... (có cả DevTools tích hợp, rất hữu ích để gỡ lỗi).
2.  **Một Trình Soạn Thảo Code:** VS Code (miễn phí, cực kỳ phổ biến và mạnh mẽ), Sublime Text, Atom, hoặc thậm chí Notepad++ cũng được.
3.  **Kết Nối Internet:** Để tra cứu và cài đặt thêm nếu cần.

### 🚦 Bước Tiếp Theo

Ở các bài học tiếp theo, chúng ta sẽ cùng đi sâu vào những khái niệm cơ bản nhất: cách lưu trữ dữ liệu (biến, kiểu dữ liệu), cách ra lệnh cho máy tính thực hiện các phép toán (toán tử), và cách điều khiển luồng thực thi chương trình (câu lệnh điều kiện, vòng lặp).

Hãy sẵn sàng để bật chế độ "deep learning" nào! 🚀
```

---

## File: 02_bien_va_kieu_du_lieu.md

```markdown
# 💾 Bài 2: Biến và Các Kiểu Dữ Liệu trong JavaScript

### ✨ Biến (Variables)

Hãy tưởng tượng bạn có một cái hộp nhỏ, bạn muốn lưu một thứ gì đó vào đó (ví dụ: số 10, hoặc đoạn văn bản "Xin chào"). Cái hộp đó chính là **biến**. Biến dùng để lưu trữ dữ liệu trong chương trình của bạn.

Trong JavaScript, bạn dùng các từ khóa sau để khai báo biến:

1.  **`var` (Cũ):** Ít được dùng trong code hiện đại do có những quirks (đặc điểm hơi khó lường) về scope.
2.  **`let` (ES6+):** Nên dùng khi bạn biết rằng giá trị của biến sẽ thay đổi. Có scope tốt hơn `var`.
3.  **`const` (ES6+):** Nên dùng khi giá trị của biến sẽ KHÔNG thay đổi sau khi được gán lần đầu. Nếu cố gắng gán lại, sẽ báo lỗi. Dùng `const` giúp code dễ đọc và an toàn hơn.

**Ví dụ:**

```javascript
let tenNguoiDung = "Alice"; // Khai báo biến tenNguoiDung với giá trị ban đầu
const PI = 3.14159;       // Khai báo hằng số PI
var tuoi = 30;            // Ví dụ dùng var (hạn chế dùng)

console.log(tenNguoiDung); // Output: Alice

tenNguoiDung = "Bob";      // Có thể thay đổi giá trị của biến let
console.log(tenNguoiDung); // Output: Bob

// PI = 3.14;            // Sẽ gây lỗi nếu cố gắng gán lại cho biến const
```

### 🏷 Quy Tắc Đặt Tên Biến

*   Tên biến có thể bắt đầu bằng chữ cái (a-z, A-Z), dấu gạch dưới (`_`), hoặc dấu đô la (`$`).
*   Các ký tự tiếp theo có thể bao gồm số (0-9).
*   Không được bắt đầu bằng số.
*   Không được dùng các từ khóa dành riêng của JavaScript (như `if`, `else`, `for`, `function`, `let`, `const`, `var`, v.v.).
*   Nên đặt tên có ý nghĩa và tuân theo quy ước (ví dụ: `camelCase` - từ đầu tiên viết thường, các từ sau viết hoa chữ cái đầu tiên, như `tenNguoiDung`).

### 🧩 Các Kiểu Dữ Liệu (Data Types)

Dữ liệu bạn lưu trong biến có thể có nhiều "loại" khác nhau. JavaScript có 8 kiểu dữ liệu (tính đến hiện tại, trong đó 7 kiểu nguyên thủy và 1 kiểu đối tượng).

**7 Kiểu Nguyên Thủy (Primitive Types):**

1.  **`string` (Chuỗi):** Biểu diễn văn bản. Được bao bọc bởi dấu nháy đơn (`'...'`), nháy kép (`"..."`), hoặc backticks (`` `...` `` - cho template literals).
    ```javascript
    let ten = "Hoàng";
    let loiChao = 'Chào bạn!';
    let thoTinh = `Đây là một dòng
    xuống dòng được này!
    Biến: ${ten}`; // Template literals cho phép nhúng biến
    ```
2.  **`number` (Số):** Biểu diễn số nguyên hoặc số thập phân. JavaScript không phân biệt rõ ràng số nguyên và số thực như một số ngôn ngữ khác.
    ```javascript
    let tuoi = 25;
    let giaTien = 99.99;
    let soLon = 1e6; // Biểu diễn số 1,000,000 (ký hiệu khoa học)
    ```
    Có các giá trị đặc biệt như `Infinity` (vô cực dương), `-Infinity` (vô cực âm), và `NaN` (Not-a-Number - không phải là số, kết quả của các phép toán không hợp lệ, ví dụ: `10 / 'abc'`).
3.  **`boolean` (Logic):** Biểu diễn một trong hai giá trị: `true` (đúng) hoặc `false` (sai). Thường dùng trong các câu lệnh điều kiện.
    ```javascript
    let daDangNhap = true;
    let isGameOver = false;
    ```
4.  **`null`:** Biểu diễn sự "rỗng", "không có giá trị", hoặc "chưa được gán giá trị một cách rõ ràng". Khác với 0 hay chuỗi rỗng.
    ```javascript
    let bienTam = null; // Khai báo và gán null
    ```
5.  **`undefined`:** Biểu diễn biến đã được *khai báo* nhưng *chưa được gán* bất kỳ giá trị nào.
    ```javascript
    let chuaDuocGanGiaTri; // Biến này mặc định có giá trị undefined
    console.log(chuaDuocGanGiaTri); // Output: undefined
    ```
    Lưu ý: Thường thì `undefined` có nghĩa là "hệ thống chưa gán", còn `null` có nghĩa là "lập trình viên chủ động gán là rỗng".
6.  **`symbol` (ES6+):** Dùng để tạo các định danh (identifiers) duy nhất. Ít gặp ở các bài học cơ bản.
    ```javascript
    const id = Symbol('id');
    ```
7.  **`bigint` (ES11+):** Dùng để biểu diễn các số nguyên có giá trị lớn hơn giới hạn của kiểu `number` thông thường.
    ```javascript
    const soRatLon = 1234567890123456789012345678901234567890n; // thêm 'n' ở cuối
    ```

**1 Kiểu Đối Tượng (Object Type):**

1.  **`object` (Đối Tượng):** Kiểu phức tạp hơn. Có thể lưu trữ các tập hợp dữ liệu và các hàm phức tạp hơn. Các ví dụ bao gồm:
    *   **Plain Object:** Dùng cặp `key: value` để lưu trữ thuộc tính.
        ```javascript
        let nguoi = {
            ten: "An",
            tuoi: 20,
            ngheNghiep: "Sinh viên"
        };
        ```
    *   **Array (Mảng):** Danh sách các giá trị được đánh số theo chỉ mục (index), bắt đầu từ 0.
        ```javascript
        let danhSachSo = [1, 2, 3, 4, 5];
        let danhSachTen = ["Alice", "Bob", "Charlie"];
        ```
    *   **Function (Hàm):** Khối code có thể gọi để thực thi lại nhiều lần.
        ```javascript
        function xinChao() {
            console.log("Xin chào các bạn!");
        }
        ```
    *   Và nhiều loại đối tượng tích hợp sẵn khác như `Date`, `RegExp`, `Map`, `Set`, v.v.

### 🔎 Kiểm Tra Kiểu Dữ Liệu (`typeof`)

Bạn có thể dùng toán tử `typeof` để kiểm tra kiểu dữ liệu của một biến hoặc một giá trị.

```javascript
console.log(typeof "hello");      // Output: "string"
console.log(typeof 123);          // Output: "number"
console.log(typeof true);         // Output: "boolean"
console.log(typeof null);         // Output: "object" (Đây là một "sai lầm" lịch sử của JS, nên typeof null trả về object dù nó là primitive type)
console.log(typeof undefined);    // Output: "undefined"
console.log(typeof { a: 1 });     // Output: "object"
console.log(typeof [1, 2]);       // Output: "object" (Mảng cũng là một loại object)
console.log(typeof function(){}); // Output: "function" (Hàm cũng là một loại object)
console.log(typeof Symbol('id')); // Output: "symbol"
console.log(typeof 10n);          // Output: "bigint"
```

### ⚙ Ép Kiểu Dữ Liệu (Type Conversion/Coercion)

JavaScript đôi khi tự động chuyển đổi kiểu dữ liệu khi thực hiện các phép toán (coercion). Tuy nhiên, bạn cũng có thể ép kiểu một cách rõ ràng.

**Chuyển sang String:**
*   `String(value)`
*   `value.toString()` (không dùng được với `null` và `undefined`)

**Chuyển sang Number:**
*   `Number(value)`
*   Toán tử `+` đứng trước giá trị (`+'123'` sẽ ra số `123`)
*   `parseInt(string)`, `parseFloat(string)` (phân tích cú pháp chuỗi để lấy số)

**Chuyển sang Boolean:**
*   `Boolean(value)`
*   Các giá trị được coi là `false` (falsy values): `0`, `""` (chuỗi rỗng), `null`, `undefined`, `NaN`, `false`.
*   Các giá trị khác đều được coi là `true` (truthy values).

**Ví dụ:**

```javascript
let soString = "123";
let soNumber = Number(soString); // soNumber = 123 (number)

let soNguy = parseInt("456px");  // soNguy = 456
let soThuc = parseFloat("7.89"); // soThuc = 7.89

let numberToString = String(12345); // numberToString = "12345" (string)

let stringToBool = Boolean("");     // stringToBool = false
let numberToBool = Boolean(10);    // numberToBool = true
let nullToBool = Boolean(null);     // nullToBool = false

console.log(5 + "5");   // Output: "55" (Số 5 bị ép thành chuỗi "5", phép cộng trở thành nối chuỗi)
console.log(5 - "2");   // Output: 3   (Chuỗi "2" bị ép thành số 2, phép trừ vẫn là phép trừ)
console.log(true + 1);  // Output: 2   (true bị ép thành số 1)
console.log(false + 1); // Output: 1   (false bị ép thành số 0)
```
Sự tự động ép kiểu (coercion) đôi khi có thể gây nhầm lẫn, đó là lý do nên hiểu rõ về nó hoặc ép kiểu một cách rõ ràng khi cần thiết.

### 🛠 Luyện Tập

Hãy thử khai báo vài biến với các kiểu dữ liệu khác nhau (string, number, boolean, null, undefined, object, array). Sử dụng `console.log` và `typeof` để in ra giá trị và kiểu của chúng. Thử các phép ép kiểu đơn giản.

---

## File: 03_toan_tu.md

```markdown
# 🧮 Bài 3: Toán Tử (Operators) trong JavaScript

Chào mừng đến với trung tâm điều khiển logic của chương trình! Toán tử là những ký hiệu đặc biệt dùng để thực hiện các thao tác trên các giá trị hoặc biến (gọi là "operand").

### ➕➖✖️➗ Toán Tử Số Học (Arithmetic Operators)

Dùng để thực hiện các phép tính toán học cơ bản.

*   `+`: Cộng
*   `-`: Trừ
*   `*`: Nhân
*   `/`: Chia
*   `%`: Chia lấy phần dư (Modulo)
*   `**`: Lũy thừa (Exponentiation, ES7+)
*   `++`: Tăng giá trị lên 1 (Increment)
*   `--`: Giảm giá trị đi 1 (Decrement)

**Ví dụ:**

```javascript
let a = 10;
let b = 5;

console.log(a + b); // Output: 15
console.log(a - b); // Output: 5
console.log(a * b); // Output: 50
console.log(a / b); // Output: 2
console.log(a % b); // Output: 0 (10 chia 5 dư 0)
console.log(2 ** 3); // Output: 8 (2 mũ 3)

let counter = 0;
counter++;         // counter = 1 (Increment sau)
console.log(counter); // Output: 1
++counter;         // counter = 2 (Increment trước)
console.log(counter); // Output: 2

let x = 5;
let y = x++;       // y = 5 (giá trị của x trước khi tăng), x = 6
console.log(x, y); // Output: 6 5

let m = 5;
let n = ++m;       // m = 6, n = 6 (giá trị của m sau khi tăng)
console.log(m, n); // Output: 6 6

// Toán tử ++ và -- cũng có dạng prefix (đặt trước biến) và postfix (đặt sau biến), khác nhau ở thứ tự lấy giá trị và tăng/giảm biến.
```

### ✍️ Toán Tử Gán (Assignment Operators)

Dùng để gán giá trị cho biến.

*   `=`: Gán đơn giản (`x = 10`)
*   `+=`: Cộng rồi gán (`x += y` tương đương `x = x + y`)
*   `-=`: Trừ rồi gán (`x -= y` tương đương `x = x - y`)
*   `*=`: Nhân rồi gán (`x *= y` tương đương `x = x * y`)
*   `/=`: Chia rồi gán (`x /= y` tương đương `x = x / y`)
*   `%=`: Modulo rồi gán (`x %= y` tương đương `x = x % y`)
*   `**=`: Lũy thừa rồi gán (`x **= y` tương đương `x = x ** y`)

**Ví dụ:**

```javascript
let count = 5;
count += 3; // count bây giờ là 8
console.log(count); // Output: 8
```

### 비교 Toán Tử So Sánh (Comparison Operators)

Dùng để so sánh hai giá trị và trả về kết quả boolean (`true` hoặc `false`).

*   `==`: Bằng giá trị (có thể bỏ qua kiểu dữ liệu - coercion)
*   `!=`: Không bằng giá trị (có thể bỏ qua kiểu dữ liệu - coercion)
*   `===`: Bằng giá trị và bằng kiểu dữ liệu (Strict equality)
*   `!==`: Không bằng giá trị hoặc không bằng kiểu dữ liệu (Strict non-equality)
*   `>`: Lớn hơn
*   `<`: Nhỏ hơn
*   `>=`: Lớn hơn hoặc bằng
*   `<=`: Nhỏ hơn hoặc bằng

**Ví dụ:**

```javascript
console.log(10 == "10");  // Output: true (10 bị ép thành chuỗi "10" hoặc ngược lại)
console.log(10 === "10"); // Output: false (khác kiểu dữ liệu)

console.log(5 != 5);      // Output: false
console.log(5 != "5");    // Output: false (giống ==)
console.log(5 !== 5);     // Output: false (cùng kiểu, cùng giá trị)
console.log(5 !== "5");   // Output: true (khác kiểu dữ liệu)

console.log(10 > 5);     // Output: true
console.log(10 < 5);     // Output: false
console.log(10 >= 10);   // Output: true
console.log(5 <= 10);    // Output: true
```
**Lưu ý quan trọng:** Luôn ưu tiên dùng `===` và `!==` để tránh các vấn đề không mong muốn do ép kiểu tự động (`==` và `!=`).

### 💡 Toán Tử Logic (Logical Operators)

Kết hợp hoặc đảo ngược các giá trị boolean.

*   `&&` (AND): Trả về `true` nếu cả hai vế đều là `true`.
*   `||` (OR): Trả về `true` nếu một trong hai vế (hoặc cả hai) là `true`.
*   `!` (NOT): Đảo ngược giá trị boolean (`true` thành `false`, `false` thành `true`).

**Ví dụ:**

```javascript
let age = 20;
let isStudent = true;

console.log(age > 18 && isStudent); // Output: true (20 > 18 là true, isStudent là true)
console.log(age < 18 || isStudent); // Output: true (isStudent là true)
console.log(!isStudent);            // Output: false

let isLoggedIn = false;
if (!isLoggedIn) {
    console.log("Vui lòng đăng nhập!");
}
```
Các toán tử `&&` và `||` có tính năng "short-circuiting" (đoản mạch). Nếu kết quả của biểu thức có thể xác định từ vế đầu tiên, vế thứ hai sẽ không được thực thi.

*   Với `&&`: Nếu vế trái là `false`, kết quả là `false` và vế phải bị bỏ qua.
*   Với `||`: Nếu vế trái là `true`, kết quả là `true` và vế phải bị bỏ qua.

Ngoài ra, `&&` và `||` cũng có thể trả về giá trị không phải boolean, tùy thuộc vào giá trị của các vế (tham khảo "Logical AND/OR return the value" trong tài liệu JS).

### ⭐ Toán Tử Ba Ngôi (Ternary Operator)

Cú pháp ngắn gọn cho câu lệnh `if...else` đơn giản.

Cú pháp: `điềuKiện ? giáTrịNếuĐúng : giáTrịNếuSai;`

**Ví dụ:**

```javascript
let canShow = (age >= 18) ? true : false; // Nếu age >= 18 là true thì canShow = true, ngược lại canShow = false

let message = (isLoggedIn) ? "Chào mừng trở lại!" : "Hãy đăng nhập để tiếp tục.";
console.log(message);
```

### 👋 Các Toán Tử Khác

*   `typeof`: Trả về kiểu dữ liệu (như đã học)
*   `instanceof`: Kiểm tra một đối tượng có phải là thể hiện (instance) của một lớp (class) cụ thể không.
*   Toán tử bitwise (thao tác trên bit): `&`, `|`, `^`, `~`, `<<`, `>>`, `>>>`.
*   ... và nhiều toán tử khác nữa!

### 🧩 Thứ Tự Ưu Tiên Của Toán Tử

Khi có nhiều toán tử trong cùng một biểu thức, JavaScript tuân theo một thứ tự ưu tiên nhất định (giống như "Nhân chia trước, cộng trừ sau" trong toán học). Bạn có thể dùng dấu ngoặc đơn `()` để thay đổi thứ tự ưu tiên này.

Ví dụ: `(a + b) * c` sẽ tính `a + b` trước rồi mới nhân với `c`.

### 🛠 Luyện Tập

*   Thử sử dụng các toán tử số học khác nhau.
*   So sánh các giá trị bằng `==`, `!=`, `===`, `!==` và quan sát kết quả.
*   Kết hợp các điều kiện bằng `&&` và `||`.
*   Chuyển một câu lệnh `if/else` đơn giản sang dùng toán tử ba ngôi.

Hiểu rõ các toán tử này giống như việc bạn có đầy đủ dụng cụ trong bộ kit của mình để xây dựng nên logic phức tạp cho chương trình vậy! Tiếp theo, chúng ta sẽ xem cách sử dụng chúng để đưa ra quyết định trong code.

---

## File: 04_cau_lenh_dieu_kien.md

```markdown
# 🚦 Bài 4: Các Câu Lệnh Điều Kiện

Lập trình không chỉ là làm theo từng bước một, mà còn là việc *đưa ra quyết định* dựa trên các tình huống khác nhau. Các câu lệnh điều kiện giúp chúng ta làm điều đó!

### 🤔 Câu Lệnh `if`

Câu lệnh `if` là cấu trúc điều kiện cơ bản nhất. Nó thực thi một khối mã chỉ khi một điều kiện nào đó là `true`.

Cú pháp:

```javascript
if (điều_kiện) {
    // Đoạn mã sẽ được thực thi nếu điều kiện là true
}
```
Trong đó, `điều_kiện` là một biểu thức (thường sử dụng toán tử so sánh hoặc logic) mà kết quả cuối cùng sẽ được ép về kiểu boolean (`true` hoặc `false`).

**Ví dụ:**

```javascript
let nhietDo = 30;

if (nhietDo > 25) {
    console.log("Trời đang nóng!");
}
```

### 👇 Câu Lệnh `if...else`

Để cung cấp một lựa chọn thay thế khi điều kiện trong `if` là `false`, chúng ta dùng `else`.

Cú pháp:

```javascript
if (điều_kiện) {
    // Đoạn mã thực thi nếu điều kiện đúng
} else {
    // Đoạn mã thực thi nếu điều kiện sai
}
```

**Ví dụ:**

```javascript
let tuoi = 17;

if (tuoi >= 18) {
    console.log("Bạn đã đủ tuổi bầu cử.");
} else {
    console.log("Bạn chưa đủ tuổi bầu cử.");
}
```

### 🧱 Câu Lệnh `if...else if...else`

Khi có nhiều hơn hai trường hợp cần xử lý, chúng ta sử dụng cấu trúc `else if`. JavaScript sẽ kiểm tra điều kiện theo thứ tự từ trên xuống. Chỉ khối mã *đầu tiên* có điều kiện là `true` mới được thực thi, và các phần còn lại (bao gồm cả `else` cuối cùng) sẽ bị bỏ qua. Phần `else` cuối cùng là tùy chọn và xử lý trường hợp không có điều kiện nào ở trên là `true`.

Cú pháp:

```javascript
if (điều_kiện_1) {
    // Code nếu điều kiện 1 đúng
} else if (điều_kiện_2) {
    // Code nếu điều kiện 2 đúng
} else if (điều_kiện_3) {
    // Code nếu điều kiện 3 đúng
} else {
    // Code nếu không có điều kiện nào ở trên đúng (tùy chọn)
}
```

**Ví dụ:**

```javascript
let diem = 85;

if (diem >= 90) {
    console.log("Điểm A - Xuất sắc!");
} else if (diem >= 80) {
    console.log("Điểm B - Giỏi.");
} else if (diem >= 70) {
    console.log("Điểm C - Khá.");
} else {
    console.log("Cần cố gắng thêm.");
}
```

### 📁 Câu Lệnh `switch`

Khi bạn có nhiều trường hợp cần kiểm tra giá trị CỦA CÙNG MỘT BIẾN, câu lệnh `switch` có thể là lựa chọn gọn gàng hơn so với chuỗi `if...else if...`.

Cú pháp:

```javascript
switch (biến_cần_kiểm_tra) {
    case gia_tri_1:
        // Code thực thi nếu biến_cần_kiểm_tra == gia_tri_1 (dùng === - strict equality)
        break; // Quan trọng: dùng break để thoát khỏi switch sau khi thực thi
    case gia_tri_2:
        // Code thực thi nếu biến_cần_kiểm_tra == gia_tri_2
        break;
    case gia_tri_3:
        // Code thực thi nếu biến_cần_kiểm_tra == gia_tri_3
        break;
    // ... thêm các case khác
    default: // Tùy chọn: code thực thi nếu biến không khớp với case nào
        // Code cho trường hợp mặc định
}
```

*   `break;`: Rất quan trọng! Nếu bỏ qua `break`, JavaScript sẽ tiếp tục thực thi code ở các `case` tiếp theo (hiện tượng "fall-through") cho đến khi gặp `break` hoặc kết thúc khối `switch`.
*   `default:`: Xử lý trường hợp không có `case` nào khớp. Nó là tùy chọn.

**Ví dụ:**

```javascript
let ngayTrongTuan = "Thứ Hai";

switch (ngayTrongTuan) {
    case "Thứ Hai":
        console.log("Bắt đầu tuần mới đầy năng lượng!");
        break;
    case "Thứ Sáu":
        console.log("Sắp cuối tuần rồi!");
        break;
    case "Thứ Bảy":
    case "Chủ Nhật": // Có thể gộp nhiều case nếu cùng xử lý một khối lệnh
        console.log("Cuối tuần, thư giãn nào!");
        break;
    default:
        console.log("Một ngày bình thường trong tuần.");
}
```

### ✨ Toán Tử Ba Ngôi (Đã giới thiệu ở bài Toán Tử, nhắc lại ở đây vì tính liên quan)

Nhắc lại một chút về toán tử ba ngôi (ternary operator): Đây là cách viết ngắn gọn cho câu lệnh `if...else` đơn giản trả về một giá trị.

Cú pháp: `điềuKiện ? giáTrịNếuĐúng : giáTrịNếuSai;`

**Ví dụ:**
```javascript
let status = (isLoggedIn) ? "Online" : "Offline";
```

### 🛠 Luyện Tập

*   Viết một câu lệnh `if` kiểm tra xem một số có dương không.
*   Mở rộng nó thành `if...else` để in ra "Số dương" hoặc "Số âm/bằng không".
*   Viết một cấu trúc `if...else if...else` để phân loại điểm số (A, B, C, D, F).
*   Viết một câu lệnh `switch` để in ra tên của tháng dựa trên số tháng (1-12).
*   Sử dụng toán tử ba ngôi để xác định tin nhắn hiển thị dựa trên trạng thái (ví dụ: đã đăng nhập/chưa đăng nhập).

Thành thạo các cấu trúc điều kiện này là bạn đã nắm trong tay bộ não điều khiển luồng chạy của chương trình rồi đấy! Giống như bạn đang lập trình các module tự hành cho phi thuyền của mình vậy! 💪

---

## File: 05_vong_lap.md

```markdown
# 🔄 Bài 5: Vòng Lặp (Loops)

Đôi khi, chúng ta cần lặp đi lặp lại một khối lệnh nhiều lần. Thay vì viết đi viết lại đoạn code đó, chúng ta sử dụng **vòng lặp**. Vòng lặp là những cỗ máy lặp tự động mạnh mẽ trong lập trình!

JavaScript cung cấp một số loại vòng lặp khác nhau:

### 🌀 Vòng Lặp `for`

Vòng lặp `for` là vòng lặp phổ biến nhất khi bạn biết trước số lần lặp (hoặc dễ dàng tính toán được).

Cú pháp:

```javascript
for (khởi_tạo; điều_kiện_tiếp_tục; cập_nhật) {
    // Đoạn mã sẽ được thực thi trong mỗi lần lặp
}
```
*   `khởi_tạo`: Thực thi *một lần duy nhất* ở đầu vòng lặp, thường dùng để khởi tạo biến đếm.
*   `điều_kiện_tiếp_tục`: Kiểm tra *trước mỗi lần lặp*. Nếu `true`, vòng lặp tiếp tục. Nếu `false`, vòng lặp dừng lại.
*   `cập_nhật`: Thực thi *sau mỗi lần lặp*, thường dùng để cập nhật biến đếm.

**Ví dụ:**

```javascript
// In ra các số từ 0 đến 4
for (let i = 0; i < 5; i++) {
    console.log("Lần lặp thứ " + i);
}

// In ra các số chẵn từ 2 đến 10
for (let j = 2; j <= 10; j += 2) {
    console.log(j);
}
```

### ✨ Vòng Lặp `while`

Vòng lặp `while` thực thi một khối lệnh *miễn là* điều kiện vẫn còn là `true`. Bạn dùng `while` khi không biết trước số lần lặp chính xác, mà chỉ biết khi nào thì vòng lặp dừng lại.

Cú pháp:

```javascript
while (điều_kiện_tiếp_tục) {
    // Đoạn mã sẽ được thực thi miễn là điều kiện là true
    // Đảm bảo có một bước cập nhật bên trong để điều kiện cuối cùng trở thành false
}
```
**Quan trọng:** Bạn phải *tự tay* thay đổi các biến trong điều kiện để điều kiện cuối cùng trở thành `false`, nếu không vòng lặp sẽ chạy mãi mãi (vòng lặp vô hạn - infinite loop), khiến trình duyệt hoặc chương trình bị treo!

**Ví dụ:**

```javascript
let count = 0;

while (count < 5) {
    console.log("Count là: " + count);
    count++; // Bước cập nhật để thoát vòng lặp
}
```

### 👇 Vòng Lặp `do...while`

Tương tự `while`, nhưng vòng lặp `do...while` *luôn* thực thi khối mã ít nhất *một lần*, trước khi kiểm tra điều kiện.

Cú pháp:

```javascript
do {
    // Đoạn mã thực thi ít nhất một lần
    // Đảm bảo có bước cập nhật
} while (điều_kiện_tiếp_tục); // Điều kiện được kiểm tra sau lần lặp đầu tiên
```

**Ví dụ:**

```javascript
let input;
let userInput = "";

do {
    input = prompt("Nhập 'thoat' để dừng:"); // Lệnh prompt hiển thị hộp thoại yêu cầu người dùng nhập liệu trong trình duyệt
    userInput += input + "\n";
} while (input !== "thoat");

console.log("Bạn đã nhập:\n" + userInput);
```
Trong ví dụ này, dù người dùng nhập "thoat" ngay lần đầu tiên, khối code bên trong `do` vẫn chạy *một lần* để hiển thị hộp thoại prompt.

### 🎯 Lệnh `break` và `continue`

*   **`break;`**: Thoát *ngay lập tức* khỏi vòng lặp gần nhất chứa nó.
*   **`continue;`**: Bỏ qua phần còn lại của *lần lặp hiện tại* và nhảy sang lần lặp tiếp theo.

**Ví dụ `break`:**

```javascript
for (let i = 0; i < 10; i++) {
    if (i === 5) {
        console.log("Tìm thấy số 5, dừng vòng lặp.");
        break; // Dừng ngay khi i bằng 5
    }
    console.log(i);
}
// Output: 0, 1, 2, 3, 4, "Tìm thấy số 5, dừng vòng lặp."
```

**Ví dụ `continue`:**

```javascript
for (let i = 0; i < 10; i++) {
    if (i % 2 === 0) { // Nếu i là số chẵn
        console.log("Bỏ qua số chẵn: " + i);
        continue; // Bỏ qua phần còn lại của lần lặp này, nhảy sang i tiếp theo
    }
    console.log("Số lẻ: " + i);
}
// Output: "Bỏ qua số chẵn: 0", "Số lẻ: 1", "Bỏ qua số chẵn: 2", "Số lẻ: 3", ...
```

### ✨ Vòng Lặp Cho Mảng và Đối Tượng (sẽ đi sâu hơn khi học Mảng và Đối Tượng)

JavaScript có các vòng lặp đặc biệt hữu ích cho việc duyệt qua các phần tử của Mảng và các thuộc tính của Đối tượng:

*   **`for...of` (ES6+):** Duyệt qua các phần tử (giá trị) của các đối tượng lặp (Iterable objects) như Mảng, Chuỗi, Map, Set...
    ```javascript
    const colors = ["red", "green", "blue"];
    for (const color of colors) {
        console.log(color); // red, green, blue
    }
    ```
*   **`for...in`:** Duyệt qua các khóa (keys/property names) của các đối tượng. CẨN THẬN khi dùng với Mảng vì nó duyệt qua cả các thuộc tính khác (như phương thức, protoype) chứ không chỉ index số, và thứ tự duyệt có thể không đảm bảo. Thường dùng cho đối tượng thường (plain objects).
    ```javascript
    const user = { name: "Anna", age: 28 };
    for (const key in user) {
        console.log(key + ": " + user[key]); // name: Anna, age: 28
    }
    ```
*   **Các Phương Thức Duyệt Mảng:** Các phương thức tích hợp của Array như `forEach()`, `map()`, `filter()`, `reduce()`... Đây là những cách *hiện đại và functional* hơn để lặp và thao tác với mảng. Sẽ học kỹ hơn ở bài về Mảng.

### 🛠 Luyện Tập

*   Sử dụng vòng lặp `for` để tính tổng các số từ 1 đến 100.
*   Sử dụng vòng lặp `while` để đếm ngược từ 10 về 0.
*   Sử dụng vòng lặp `do...while` để yêu cầu người dùng nhập mật khẩu cho đến khi nhập đúng (với một mật khẩu "giả" nào đó).
*   Kết hợp `break` hoặc `continue` trong các vòng lặp trên.
*   (Thử) Dùng `for...of` để in từng ký tự của một chuỗi.

Nắm vững vòng lặp giống như bạn đã lắp thêm hệ thống đẩy và định vị vào phi thuyền của mình vậy! Nó cho phép bạn thực hiện các tác vụ lặp đi lặp lại một cách tự động và hiệu quả.

---

## File: 06_ham.md

```markdown
# 🧱 Bài 6: Hàm (Functions)

Trong lập trình, chúng ta thường có những khối mã thực hiện một công việc cụ thể, lặp đi lặp lại hoặc có thể cần tái sử dụng ở nhiều nơi khác nhau. **Hàm** là công cụ cho phép chúng ta đóng gói những khối mã này lại, đặt tên cho chúng và gọi chúng để thực thi khi cần. Điều này giúp code của bạn ngăn nắp, dễ đọc, dễ bảo trì và tránh lặp lại chính mình (Nguyên tắc DRY - Don't Repeat Yourself).

Hãy nghĩ hàm như những "robot" chuyên dụng của bạn, mỗi robot làm một việc riêng biệt!

### 🤖 Khai Báo Hàm (Function Declaration)

Đây là cách khai báo hàm truyền thống.

Cú pháp:

```javascript
function tenHam(tham_số_1, tham_số_2, ...) {
    // Khối mã của hàm
    // Có thể thực hiện các lệnh
    // Có thể trả về một giá trị
    return gia_tri; // Tùy chọn
}
```

*   `function`: Từ khóa để khai báo hàm.
*   `tenHam`: Tên của hàm (tuân theo quy tắc đặt tên biến).
*   `(tham_số_1, tham_số_2, ...)`: Danh sách các tham số mà hàm nhận vào (đặt trong ngoặc đơn, cách nhau bởi dấu phẩy). Tham số là tùy chọn.
*   `{ ... }`: Khối mã (body) của hàm.
*   `return`: Từ khóa dùng để trả về một giá trị từ hàm. Nếu không có `return` (hoặc `return;`), hàm sẽ trả về `undefined` mặc định.

**Ví dụ:**

```javascript
function chaoTheGioi() {
    console.log("Xin chào, thế giới!");
}

function tinhTong(a, b) {
    return a + b; // Hàm trả về tổng của a và b
}

// Gọi hàm để thực thi
chaoTheGioi(); // Output: Xin chào, thế giới!

let ketQua = tinhTong(5, 7);
console.log("Tổng là: " + ketQua); // Output: Tổng là: 12
console.log("Tổng khác: " + tinhTong(10, 20)); // Output: Tổng khác: 30
```

### 🚀 Biểu Thức Hàm (Function Expression)

Một hàm cũng có thể được gán cho một biến, giống như bất kỳ giá trị nào khác.

Cú pháp:

```javascript
let tenBienChuaHam = function(tham_số_1, ...) {
    // Khối mã
}; // Chú ý dấu chấm phẩy ở cuối
```

**Ví dụ:**

```javascript
let sayHello = function() {
    console.log("Hi!");
};

sayHello(); // Output: Hi!

let multiply = function(x, y) {
    return x * y;
};

console.log("Kết quả nhân: " + multiply(3, 4)); // Output: Kết quả nhân: 12
```
Sự khác biệt chính giữa khai báo hàm và biểu thức hàm liên quan đến Hoisting (sẽ nói kỹ hơn sau): Khai báo hàm có thể được gọi *trước* khi nó được định nghĩa trong code, còn biểu thức hàm thì không.

### 🏹 Hàm Mũ Tên (Arrow Functions - ES6+)

Cú pháp ngắn gọn và hiện đại để viết hàm, đặc biệt hữu ích cho các hàm đơn giản.

Cú pháp cơ bản:

```javascript
let tenHam = (tham_số_1, ...) => {
    // Khối mã
    return gia_tri;
};
```

*   Nếu chỉ có MỘT tham số, có thể bỏ qua dấu ngoặc đơn `()` ở tham số.
    `let gapDoi = so => { return so * 2; };`
*   Nếu hàm CHỈ có một dòng lệnh `return` biểu thức, có thể bỏ qua `{}`, `return`, và dấu chấm phẩy.
    `let gapDoi = so => so * 2;` // Rất ngắn gọn!
*   Nếu không có tham số nào, cần cặp ngoặc đơn rỗng `()`.
    `let sayGoodbye = () => console.log("Goodbye!");`

**Ví dụ:**

```javascript
let chia = (a, b) => {
    if (b === 0) {
        return "Không thể chia cho 0";
    }
    return a / b;
};

let binhPhuong = so => so * so; // Cú pháp ngắn gọn

console.log(chia(10, 2));     // Output: 5
console.log(chia(10, 0));     // Output: Không thể chia cho 0
console.log(binhPhuong(5));   // Output: 25
```
Hàm mũi tên có một số khác biệt quan trọng so với hàm truyền thống về cách xử lý `this` (sẽ tìm hiểu ở bài nâng cao), khiến chúng rất phù hợp cho các hàm callback.

### 🔄 Tham Số Mặc Định (Default Parameters - ES6+)

Bạn có thể gán một giá trị mặc định cho tham số. Nếu khi gọi hàm, bạn không truyền giá trị cho tham số đó, giá trị mặc định sẽ được sử dụng.

**Ví dụ:**

```javascript
function chao(ten = "bạn ẩn danh") { // Gán giá trị mặc định "bạn ẩn danh" cho tham số ten
    console.log("Xin chào, " + ten + "!");
}

chao("Quân"); // Output: Xin chào, Quân!
chao();      // Output: Xin chào, bạn ẩn danh! (Không truyền tham số nào)
```

### 📚 Scope (Phạm Vi) của Biến trong Hàm

Các biến được khai báo *bên trong* một hàm (sử dụng `let` hoặc `const`) chỉ tồn tại và có thể truy cập được *trong phạm vi* của hàm đó. Chúng được gọi là biến **local (cục bộ)**. Các biến được khai báo *bên ngoài* bất kỳ hàm nào là biến **global (toàn cục)** và có thể truy cập được ở mọi nơi.

**Ví dụ:**

```javascript
let bienGlobal = "Tôi là toàn cục"; // Biến Global

function hamViDu() {
    let bienLocal = "Tôi chỉ là cục bộ"; // Biến Local
    console.log(bienGlobal); // Có thể truy cập biến Global
    console.log(bienLocal);  // Có thể truy cập biến Local
}

hamViDu();

console.log(bienGlobal); // Có thể truy cập biến Global
// console.log(bienLocal); // Sẽ gây lỗi: ReferenceError, bienLocal không tồn tại ở ngoài hàm
```
Hiểu về phạm vi (scope) rất quan trọng để tránh nhầm lẫn giữa các biến và giữ cho code của bạn ngăn nắp, an toàn.

### ⚙️ Khi Nào Sử Dụng Hàm?

*   Khi có một khối mã thực hiện một công việc cụ thể.
*   Khi bạn cần thực hiện công việc đó nhiều lần.
*   Khi bạn muốn làm cho code của mình dễ đọc hơn bằng cách chia nhỏ nó thành các phần logic có tên rõ ràng.
*   Khi bạn muốn tránh việc lặp lại code.

### 🛠 Luyện Tập

*   Viết một hàm khai báo (function declaration) nhận vào hai số và trả về số lớn hơn.
*   Viết một biểu thức hàm (function expression) nhận vào một chuỗi và trả về chuỗi viết hoa tất cả các ký tự.
*   Chuyển đổi hàm vừa rồi thành hàm mũi tên (arrow function) với cú pháp ngắn gọn nhất có thể.
*   Viết một hàm với tham số mặc định. Gọi hàm với và không có tham số đó.
*   Quan sát sự khác biệt về scope bằng cách khai báo biến trong và ngoài hàm, rồi thử truy cập chúng.

Hàm là một trong những viên gạch cấu tạo cốt lõi của bất kỳ chương trình nào. Nắm vững hàm là bạn đã có thể bắt đầu xây dựng những "tòa nhà" phức tạp hơn từ những khối "robot" chuyên dụng này rồi!

---

## File: 07_mang_array.md

```markdown
# 🧱 Bài 7: Mảng (Arrays)

Trong cuộc sống, chúng ta thường làm việc với danh sách: danh sách mua sắm, danh sách sinh viên, danh sách các hành tinh,... Trong lập trình, khi muốn lưu trữ một **tập hợp các giá trị** (có thể cùng kiểu hoặc khác kiểu, dù thường là cùng kiểu), chúng ta sử dụng **Mảng (Array)**.

Mảng trong JavaScript giống như một "tủ kéo" kỹ thuật số, mỗi ngăn kéo được đánh số, và bạn có thể bỏ bất cứ thứ gì vào đó.

### 🛠 Khai Báo Mảng

Có hai cách phổ biến để tạo mảng:

1.  **Dùng Literal Mảng (Array Literal - phổ biến nhất):**
    ```javascript
    let danhSachRong = []; // Mảng rỗng
    let cacLoaiQua = ["Táo", "Chuối", "Cam"]; // Mảng với các phần tử ban đầu (kiểu string)
    let cacLoaiSo = [1, 2, 3, 4, 5]; // Mảng với các phần tử kiểu number
    let honTap = [1, "Hai", true, { ten: "Đối tượng" }]; // Mảng có thể chứa các kiểu dữ liệu khác nhau
    ```

2.  **Dùng Constructor `Array()`:**
    ```javascript
    let arr1 = new Array(); // Mảng rỗng
    let arr2 = new Array(3); // Mảng rỗng với dung lượng ban đầu là 3 (có 3 vị trí empty)
    let arr3 = new Array("A", "B", "C"); // Mảng với các phần tử ban đầu
    ```
    Cách dùng literal mảng thường được ưu tiên vì ngắn gọn và dễ đọc hơn.

### 📦 Truy Cập và Sửa Đổi Phần Tử Mảng

Các phần tử trong mảng được đánh số thứ tự (gọi là **chỉ mục - index**), BẮT ĐẦU TỪ **0**.

*   **Truy cập:** Sử dụng ngoặc vuông `[]` và chỉ mục.
    ```javascript
    let colors = ["Red", "Green", "Blue"];
    console.log(colors[0]); // Output: Red (Phần tử ở chỉ mục 0)
    console.log(colors[1]); // Output: Green
    console.log(colors[2]); // Output: Blue
    ```
*   **Sửa đổi:** Sử dụng chỉ mục và toán tử gán `=`.
    ```javascript
    let numbers = [10, 20, 30];
    numbers[1] = 25; // Sửa phần tử ở chỉ mục 1
    console.log(numbers); // Output: [10, 25, 30]
    ```
*   Nếu truy cập một chỉ mục *không tồn tại*, kết quả sẽ là `undefined`.
    ```javascript
    let simpleArray = [1, 2];
    console.log(simpleArray[10]); // Output: undefined
    ```
*   Bạn có thể thêm phần tử mới bằng cách gán giá trị cho một chỉ mục lớn hơn chỉ mục cuối cùng. Các chỉ mục ở giữa chưa được gán sẽ là `empty`.
    ```javascript
    let anotherArray = ["A", "B"];
    anotherArray[4] = "E";
    console.log(anotherArray); // Output: ["A", "B", empty, empty, "E"]
    console.log(anotherArray.length); // Output: 5
    ```

### 📏 Độ Dài Mảng (`length`)

Thuộc tính `length` trả về số lượng phần tử trong mảng.

```javascript
let danhSachSinhVien = ["An", "Bình", "Cường"];
console.log(danhSachSinhVien.length); // Output: 3

// Lưu ý: Thay đổi thuộc tính length có thể cắt ngắn hoặc kéo dài mảng
danhSachSinhVien.length = 1; // Cắt ngắn mảng
console.log(danhSachSinhVien); // Output: ["An"]
```

### 🚀 Các Phương Thức Mảng Quan Trọng (Array Methods)

Mảng có rất nhiều phương thức tích hợp sẵn để thực hiện các thao tác phổ biến một cách hiệu quả.

*   **Thêm/Xóa phần tử ở CUỐI mảng:**
    *   `push(phanTu1, phanTu2, ...)`: Thêm các phần tử vào cuối mảng. Trả về độ dài mới của mảng.
    *   `pop()`: Xóa phần tử cuối cùng của mảng. Trả về phần tử bị xóa.
    ```javascript
    let fruits = ["Apple", "Banana"];
    fruits.push("Orange"); // fruits bây giờ là ["Apple", "Banana", "Orange"]
    let lastFruit = fruits.pop(); // lastFruit là "Orange", fruits là ["Apple", "Banana"]
    ```

*   **Thêm/Xóa phần tử ở ĐẦU mảng:** (Ít dùng hơn `push/pop` vì có thể chậm hơn với mảng lớn do phải dịch chuyển các phần tử còn lại)
    *   `unshift(phanTu1, phanTu2, ...)`: Thêm các phần tử vào đầu mảng. Trả về độ dài mới.
    *   `shift()`: Xóa phần tử đầu tiên của mảng. Trả về phần tử bị xóa.
    ```javascript
    let animals = ["Tiger", "Lion"];
    animals.unshift("Elephant"); // animals bây giờ là ["Elephant", "Tiger", "Lion"]
    let firstAnimal = animals.shift(); // firstAnimal là "Elephant", animals là ["Tiger", "Lion"]
    ```

*   **Xóa/Thay thế/Thêm phần tử tại BẤT KỲ VỊ TRÍ NÀO:**
    *   `splice(indexBắtĐầu, sốLượngPhầnTửMuốnXóa, phanTu1MuốnThem, phanTu2MuốnThem, ...)`
        *   `indexBắtĐầu`: Vị trí (chỉ mục) bắt đầu thực hiện thao tác.
        *   `sốLượngPhầnTửMuốnXóa`: Số lượng phần tử muốn xóa kể từ `indexBắtĐầu`. Nếu là 0, sẽ không xóa phần tử nào.
        *   `phanTu...MuốnThem`: Các phần tử tùy chọn muốn thêm vào bắt đầu từ `indexBắtĐầu`.
    *   `splice` trả về một mảng chứa các phần tử đã bị xóa (nếu có).
    ```javascript
    let arr = [1, 2, 3, 4, 5];
    let deletedItems1 = arr.splice(1, 2); // Xóa 2 phần tử từ chỉ mục 1: [2, 3]
    // arr bây giờ là [1, 4, 5]
    console.log(arr, deletedItems1); // Output: [1, 4, 5] [2, 3]

    let arr2 = [1, 2, 3];
    let deletedItems2 = arr2.splice(1, 0, "a", "b"); // Từ chỉ mục 1, xóa 0 phần tử, thêm "a", "b"
    // arr2 bây giờ là [1, "a", "b", 2, 3]
    console.log(arr2, deletedItems2); // Output: [1, "a", "b", 2, 3] [] (Không có phần tử nào bị xóa)
    ```

*   **Tạo một bản sao MỚI của mảng hoặc một phần của mảng:**
    *   `slice(indexBắtĐầu, indexKếtThúc)`
        *   `indexBắtĐầu`: Chỉ mục BẮT ĐẦU (bao gồm).
        *   `indexKếtThúc`: Chỉ mục KẾT THÚC (KHÔNG bao gồm).
        *   Nếu bỏ qua cả hai tham số, nó tạo bản sao của toàn bộ mảng.
    *   `slice` KHÔNG thay đổi mảng gốc.
    ```javascript
    let originalArray = [1, 2, 3, 4, 5];
    let saoChep = originalArray.slice();    // Sao chép toàn bộ: [1, 2, 3, 4, 5]
    let phanCon = originalArray.slice(1, 3); // Lấy từ chỉ mục 1 đến trước chỉ mục 3: [2, 3]
    let denCuoi = originalArray.slice(2);   // Lấy từ chỉ mục 2 đến cuối: [3, 4, 5]

    console.log(saoChep, phanCon, denCuoi);
    console.log(originalArray); // Mảng gốc không thay đổi
    ```

*   **Tìm kiếm phần tử:**
    *   `indexOf(phanTu, startIndex)`: Trả về chỉ mục ĐẦU TIÊN của `phanTu`, tìm kiếm từ `startIndex`. Trả về `-1` nếu không tìm thấy.
    *   `lastIndexOf(phanTu, startIndex)`: Trả về chỉ mục CUỐI CÙNG.
    *   `includes(phanTu, startIndex)` (ES7+): Trả về `true` nếu mảng chứa `phanTu`, `false` nếu không.

*   **Duyệt (lặp qua) Mảng:**
    *   Dùng vòng lặp `for` truyền thống (`for (let i = 0; i < array.length; i++)`).
    *   Dùng vòng lặp `for...of` (duyệt qua giá trị).
    *   Dùng phương thức `forEach()`: Thực thi một hàm (callback) cho MỖI phần tử của mảng.
        ```javascript
        let numbers = [10, 20, 30];
        numbers.forEach(function(item, index, array) {
            console.log(`Phần tử ${item} ở chỉ mục ${index} trong mảng ${array}`);
        });
        // Cũng có thể dùng arrow function
        numbers.forEach((item, index) => {
             console.log(`Item: ${item}, Index: ${index}`);
        });
        ```
    `forEach` không dừng được bằng `break`, muốn dừng giữa chừng phải dùng vòng lặp `for`, `while` hoặc các phương thức khác như `some()`, `every()`.

### 📌 Lưu Ý: Mảng là Đối Tượng (Object)

Mảng trong JavaScript thực chất là một kiểu đặc biệt của đối tượng. Chỉ mục số (index) được coi như là các "khóa" (keys) ở dạng chuỗi, và thuộc tính `length` được cập nhật tự động khi bạn thêm/xóa phần tử bằng các phương thức như `push`, `pop`, `shift`, `unshift`, `splice` hoặc gán trực tiếp qua index *tăng dần* như `arr[arr.length] = newValue;`.

Tuy nhiên, chúng ta thường xem mảng như một cấu trúc dữ liệu riêng vì cách thao tác và các phương thức chuyên dụng của nó.

### 🛠 Luyện Tập

*   Tạo một mảng chứa tên của 5 cuốn sách yêu thích của bạn.
*   In ra tên cuốn sách đầu tiên và cuối cùng trong mảng.
*   Thêm một cuốn sách mới vào cuối mảng.
*   Xóa cuốn sách đầu tiên.
*   Sử dụng `splice` để chèn thêm 2 cuốn sách vào giữa mảng.
*   Sử dụng `slice` để tạo một mảng mới chỉ chứa 3 cuốn sách ở giữa của mảng ban đầu.
*   Dùng vòng lặp `for`, `for...of` và phương thức `forEach` để in ra tất cả tên sách trong mảng.

Mảng là một cấu trúc dữ liệu vô cùng quan trọng và tiện lợi. Nó là nền tảng để xử lý các bộ sưu tập dữ liệu. Hãy dành thời gian thực hành các phương thức mảng, chúng sẽ là những trợ thủ đắc lực cho bạn!

---

## File: 08_doi_tuong_objects.md

```markdown
# 🪐 Bài 8: Đối Tượng (Objects)

Ngoài các kiểu dữ liệu nguyên thủy như chuỗi, số, boolean,... chúng ta còn có kiểu **Object**. Object trong JavaScript giống như các "vật thể" trong thế giới thực, chúng có các **thuộc tính (properties)** (ví dụ: màu sắc, kích thước, tên) và có thể có **hành động (methods)** (ví dụ: chạy, nói, tính toán).

Object là cách để nhóm dữ liệu và chức năng liên quan lại với nhau thành một đơn vị duy nhất.

Hãy nghĩ Object như những "bản thiết kế" hoặc "các thực thể" mà bạn xây dựng trong thế giới kỹ thuật số của mình.

### 🛠 Khai Báo Đối Tượng

Cách phổ biến nhất và dễ nhất là dùng **Object Literal**:

```javascript
// Khai báo một đối tượng RỖNG
let nguoi = {};

// Khai báo một đối tượng với các thuộc tính ban đầu
let nguoiMay = {
    // key: value (cặp khóa-giá trị)
    ten: "Model XYZ",
    mauSac: "Bạc",
    namSanXuat: 2050,
    dangHoatDong: true
};
```
Trong `Object Literal`, bạn định nghĩa các thuộc tính dưới dạng các cặp `key: value` (khóa và giá trị) cách nhau bằng dấu phẩy. Key (khóa) thường là chuỗi (bạn có thể bỏ dấu ngoặc kép nếu tên khóa hợp lệ như tên biến), và value (giá trị) có thể là bất kỳ kiểu dữ liệu nào (bao gồm cả các object khác hoặc hàm).

### 📦 Truy Cập và Sửa Đổi Thuộc Tính

Có hai cách chính để truy cập và sửa đổi thuộc tính của object:

1.  **Dùng Dấu Chấm (`.` - Dot Notation):** Phổ biến khi bạn biết tên thuộc tính (khóa).
    ```javascript
    console.log(nguoiMay.ten);       // Output: Model XYZ
    console.log(nguoiMay.namSanXuat); // Output: 2050

    nguoiMay.mauSac = "Vàng";      // Sửa giá trị thuộc tính
    console.log(nguoiMay.mauSac);   // Output: Vàng

    nguoiMay.canNang = 150;         // Thêm thuộc tính mới
    console.log(nguoiMay.canNang);  // Output: 150
    ```

2.  **Dùng Ngoặc Vuông (`[]` - Bracket Notation):** Hữu ích khi tên thuộc tính phức tạp (có dấu cách, ký tự đặc biệt) hoặc khi tên thuộc tính được lưu trong một biến.
    ```javascript
    let sach = {
        tieuDe: "Hành trình giữa các vì sao",
        "tac gia": "Arthur C. Clarke", // Tên thuộc tính có dấu cách
        namXuatBan: 1968
    };

    console.log(sach["tieuDe"]);     // Output: Hành trình giữa các vì sao
    console.log(sach["tac gia"]);    // Output: Arthur C. Clarke (BẮT BUỘC phải dùng ngoặc vuông)

    let keyTacGia = "tac gia";
    console.log(sach[keyTacGia]);    // Output: Arthur C. Clarke (Truy cập tên thuộc tính lưu trong biến)

    sach["namXuatBan"] = 2001;        // Sửa thuộc tính
    console.log(sach.namXuatBan);     // Output: 2001

    sach["ngon ngu"] = "Tiếng Anh"; // Thêm thuộc tính
    console.log(sach["ngon ngu"]);  // Output: Tiếng Anh
    ```

### ✨ Thêm Phương Thức (Methods) cho Đối Tượng

Nếu giá trị của một thuộc tính là một **hàm**, thuộc tính đó được gọi là **phương thức** của đối tượng. Phương thức biểu diễn "hành động" mà đối tượng có thể thực hiện.

**Ví dụ:**

```javascript
let mayTinh = {
    // Thuộc tính
    nhanHieu: "Cosmic Corp",
    loaiCPU: "Quantium-X",
    gia: 2500,

    // Phương thức
    bat: function() { // Dùng Function Expression
        console.log(this.nhanHieu + " đang khởi động...");
    },
    tat: function() {
        console.log(this.nhanHieu + " đang tắt.");
    },
    tinhGiaSauKhuyenMai: function(tyLe) { // Hàm nhận tham số
        return this.gia * (1 - tyLe);
    },
    baoCao: () => { // CẨN THẬN khi dùng Arrow function làm method
        // 'this' trong arrow function KHÔNG trỏ đến object mayTinh mà trỏ ra ngoài (global object)
        //console.log("Thông tin: " + this.nhanHieu); // --> Sẽ in ra 'undefined' hoặc thông tin global
        console.log("Máy đang hoạt động.");
    }
};

// Gọi phương thức
mayTinh.bat();                      // Output: Cosmic Corp đang khởi động...
mayTinh["tat"]();                   // Cũng gọi được bằng ngoặc vuông
let giaSauKM = mayTinh.tinhGiaSauKhuyenMai(0.1); // Tính giá giảm 10%
console.log("Giá sau khuyến mãi: $" + giaSauKM); // Output: Giá sau khuyến mãi: $2250

mayTinh.baoCao(); // Output: Máy đang hoạt động. (Lưu ý: ví dụ này tránh dùng 'this')
```

*   **Từ khóa `this`:** Trong một phương thức (được định nghĩa bằng `function`), từ khóa `this` trỏ đến chính đối tượng chứa phương thức đó. Điều này cho phép bạn truy cập các thuộc tính khác của đối tượng bên trong phương thức. **Như đã đề cập, `this` trong arrow function hoạt động khác.**

### 🗑 Xóa Thuộc Tính

Dùng toán tử `delete` để xóa một thuộc tính của object.

```javascript
let sinhVien = { ten: "Linh", tuoi: 19, nganh: "Khoa học máy tính" };
console.log(sinhVien);       // Output: { ten: 'Linh', tuoi: 19, nganh: 'Khoa học máy tính' }

delete sinhVien.tuoi;        // Xóa thuộc tính tuoi
delete sinhVien["nganh"];    // Xóa thuộc tính nganh dùng ngoặc vuông

console.log(sinhVien);       // Output: { ten: 'Linh' }
```

### 🔍 Kiểm Tra Sự Tồn Tại Của Thuộc Tính

*   **Toán tử `in`:**
    ```javascript
    console.log("ten" in sinhVien);    // Output: true
    console.log("tuoi" in sinhVien);   // Output: false (đã bị xóa)
    ```
*   **So sánh với `undefined`:**
    ```javascript
    console.log(sinhVien.nganh === undefined); // Output: true (sau khi bị xóa)
    ```
    Lưu ý: Cách so sánh với `undefined` không phân biệt được thuộc tính không tồn tại và thuộc tính tồn tại nhưng có giá trị là `undefined`. Toán tử `in` đáng tin cậy hơn trong việc kiểm tra *sự tồn tại* thực sự của thuộc tính.

### ♻️ Duyệt (lặp qua) Đối Tượng

Dùng vòng lặp `for...in` để lặp qua các khóa (tên thuộc tính) của object.

```javascript
let robot = { model: "RT1", chucNang: ["Đi", "Nói"], daKhoiDong: true };

for (let key in robot) {
    // 'key' sẽ là "model", "chucNang", "daKhoiDong"
    console.log(key + ": " + robot[key]);
}
/*
Output:
model: RT1
chucNang: Đi,Nói (Khi in mảng, nó được chuyển thành chuỗi)
daKhoiDong: true
*/
```
Lưu ý về `for...in` đã nhắc ở bài vòng lặp: nó cũng duyệt qua các thuộc tính "thừa kế" từ prototype. Để tránh điều này và chỉ duyệt qua các thuộc tính "trực tiếp" của đối tượng, bạn có thể thêm điều kiện kiểm tra:

```javascript
for (let key in robot) {
    if (robot.hasOwnProperty(key)) { // Kiểm tra xem thuộc tính có phải của riêng object đó không
         console.log(key + ": " + robot[key]);
    }
}
```
*   **Các Phương Thức Object Khác (ES6+):**
    *   `Object.keys(obj)`: Trả về một MẢNG chứa tên (khóa) của các thuộc tính "đếm được" (enumerable) của object.
    *   `Object.values(obj)`: Trả về một MẢNG chứa giá trị của các thuộc tính "đếm được" của object.
    *   `Object.entries(obj)`: Trả về một MẢNG chứa các cặp `[khóa, giá trị]` dưới dạng mảng con, cho các thuộc tính "đếm được".

    ```javascript
    console.log(Object.keys(robot));   // Output: ['model', 'chucNang', 'daKhoiDong']
    console.log(Object.values(robot)); // Output: ['RT1', ['Đi', 'Nói'], true]
    console.log(Object.entries(robot)); // Output: [['model', 'RT1'], ['chucNang', ['Đi', 'Nói']], ['daKhoiDong', true]]
    ```
    Sau đó bạn có thể sử dụng các vòng lặp thông thường (`for`, `for...of`, `forEach`) để duyệt qua các mảng trả về từ các phương thức này.

### 🛠 Luyện Tập

*   Tạo một object biểu diễn thông tin về một hành tinh (ví dụ: tên, khối lượng, có vệ tinh không, danh sách các vệ tinh nếu có).
*   Truy cập và in ra các thuộc tính của hành tinh đó bằng cả Dot Notation và Bracket Notation.
*   Thêm một thuộc tính mới (ví dụ: "khoảng cách từ mặt trời").
*   Viết một phương thức cho object hành tinh, ví dụ: phương thức `moTa()` in ra tóm tắt thông tin về hành tinh đó.
*   Dùng vòng lặp `for...in` để in ra tất cả các thuộc tính và giá trị của object hành tinh.
*   (Nâng cao) Sử dụng `Object.keys()` và `forEach` để in ra tương tự.

Đối tượng là trái tim của lập trình hướng đối tượng trong JavaScript. Hiểu về cách tạo, thao tác và duyệt object sẽ mở ra cánh cửa tới các kiến thức nâng cao hơn rất nhiều! Hãy coi đây là việc bạn đang chế tạo ra những cấu trúc dữ liệu phức tạp của riêng mình vậy! 🌌

---

## File: 09_dom_va_su_kien_intro.md

```markdown
# 🖥️ Bài 9: Thao Tác Với DOM và Xử Lý Sự Kiện (Giới thiệu)

Cho đến bây giờ, chúng ta chủ yếu chạy code trong console. Tuyệt vời đấy, nhưng làm sao để JavaScript có thể "nói chuyện" với trang web thực tế và phản ứng với người dùng? Câu trả lời nằm ở **DOM (Document Object Model)** và **Xử Lý Sự Kiện (Event Handling)**.

Hãy coi trang web HTML của bạn như một bản đồ thiết kế kiến trúc, và JavaScript là đội robot xây dựng có thể đọc bản đồ đó (DOM) và phản ứng lại các sự kiện xảy ra (người dùng bấm vào nút, nhập dữ liệu...).

### 🏗️ DOM (Document Object Model) là gì?

Khi trình duyệt tải một trang HTML, nó sẽ tạo ra một mô hình cấu trúc dạng cây (tree structure) của trang đó. Mô hình này gọi là DOM. Mỗi thẻ HTML (như `<html>`, `<head>`, `<body>`, `<p>`, `<div>`, `<button>`) đều trở thành một **nút (node)** trong cây DOM.

DOM cung cấp một API (Application Programming Interface) cho phép JavaScript:

*   Tìm kiếm các phần tử HTML (các nút trong cây DOM).
*   Thay đổi nội dung văn bản và thuộc tính của các phần tử.
*   Thay đổi kiểu dáng CSS của các phần tử.
*   Thêm mới hoặc xóa bỏ các phần tử.
*   Phản ứng với các sự kiện của người dùng.

### 🎯 Truy Cập Các Phần Tử HTML (Chọn Element)

Đây là bước đầu tiên: tìm phần tử bạn muốn thao tác!

Các phương thức phổ biến trong đối tượng `document` (đại diện cho toàn bộ trang web):

*   `document.getElementById('id_cua_phan_tu')`: Tìm một phần tử duy nhất dựa trên thuộc tính `id`. Trả về phần tử hoặc `null` nếu không tìm thấy. ID phải là duy nhất trên trang!
*   `document.getElementsByClassName('class_cua_cac_phan_tu')`: Tìm tất cả phần tử có cùng thuộc tính `class`. Trả về một **HTMLCollection** (giống mảng, nhưng không có tất cả các phương thức mảng).
*   `document.getElementsByTagName('ten_the_html')`: Tìm tất cả phần tử có cùng tên thẻ (ví dụ: 'p', 'div', 'button'). Trả về một HTMLCollection.
*   `document.querySelector('css_selector')`: Tìm **phần tử ĐẦU TIÊN** khớp với CSS selector được chỉ định (có thể là id, class, tên thẻ, kết hợp,...).
*   `document.querySelectorAll('css_selector')`: Tìm **TẤT CẢ** các phần tử khớp với CSS selector. Trả về một **NodeList** (giống mảng hơn HTMLCollection).

**Ví dụ HTML:**

```html
<!DOCTYPE html>
<html>
<head>
    <title>Demo DOM</title>
</head>
<body>
    <h1 id="tieuDe">Chào Mừng</h1>
    <p class="doanVan">Đây là đoạn văn thứ nhất.</p>
    <p class="doanVan">Đây là đoạn văn thứ hai.</p>
    <button id="nutBam">Bấm vào đây!</button>

    <script src="script.js"></script> <!-- Nơi chúng ta sẽ viết JS -->
</body>
</html>
```

**Ví dụ JS (`script.js`):**

```javascript
// Truy cập phần tử bằng ID
let tieuDeElement = document.getElementById('tieuDe');
console.log(tieuDeElement); // In ra toàn bộ phần tử h1

// Truy cập các phần tử bằng Class
let doanVanElements = document.getElementsByClassName('doanVan');
console.log(doanVanElements); // In ra HTMLCollection chứa cả hai đoạn văn

// Truy cập các phần tử bằng Tên thẻ
let paragraphElements = document.getElementsByTagName('p');
console.log(paragraphElements); // In ra HTMLCollection chứa cả hai thẻ p

// Truy cập phần tử ĐẦU TIÊN khớp với selector
let firstParagraph = document.querySelector('.doanVan'); // Chọn thẻ có class 'doanVan' đầu tiên
console.log(firstParagraph);

let buttonElement = document.querySelector('#nutBam'); // Chọn thẻ có ID 'nutBam'
console.log(buttonElement);

// Truy cập TẤT CẢ phần tử khớp với selector
let allParagraphs = document.querySelectorAll('.doanVan'); // Chọn tất cả thẻ có class 'doanVan'
console.log(allParagraphs); // In ra NodeList
```

### ✏️ Thao Tác Với Nội Dung và Thuộc Tính

Sau khi có được một phần tử DOM, bạn có thể thay đổi nó:

*   `element.innerHTML`: Lấy hoặc đặt toàn bộ nội dung HTML bên trong phần tử (có thể chứa cả thẻ HTML).
*   `element.textContent`: Lấy hoặc đặt chỉ nội dung văn bản bên trong phần tử (an toàn hơn `innerHTML` khi làm việc với dữ liệu từ người dùng để tránh tấn công XSS).
*   `element.attributeName`: Lấy hoặc đặt giá trị của các thuộc tính HTML thông thường (ví dụ: `element.id`, `element.src`, `element.href`).
*   `element.setAttribute(name, value)`: Đặt giá trị cho một thuộc tính bất kỳ.
*   `element.getAttribute(name)`: Lấy giá trị của một thuộc tính bất kỳ.
*   `element.removeAttribute(name)`: Xóa một thuộc tính.

**Ví dụ (`script.js` tiếp theo):**

```javascript
// Thay đổi nội dung
tieuDeElement.textContent = "Chào mừng bạn đã đến với hệ thống!"; // Thay đổi chỉ text
// tieuDeElement.innerHTML = "<span>Nội dung MỚI</span>"; // Thay đổi cả HTML bên trong

// Thay đổi thuộc tính
let linkElement = document.createElement('a'); // Tạo thẻ 'a' mới (sẽ học sau)
linkElement.href = "https://viblo.asia"; // Đặt thuộc tính href
linkElement.setAttribute('target', '_blank'); // Đặt thuộc tính target bằng setAttribute
linkElement.textContent = "Đến Viblo";
// Để linkElement hiển thị, bạn cần chèn nó vào DOM

// Ví dụ sửa đổi thuộc tính của một hình ảnh (nếu có img trên trang)
// let imgElement = document.querySelector('img');
// imgElement.src = 'duong/dan/anh/moi.jpg';
// imgElement.setAttribute('alt', 'Hình ảnh mới');
```

### 🎨 Thay Đổi Kiểu Dáng (CSS)

Bạn có thể truy cập và sửa đổi các thuộc tính CSS của một phần tử thông qua thuộc tính `style`. Tên thuộc tính CSS gạch nối (như `background-color`) được chuyển thành `camelCase` (như `backgroundColor`) trong JS.

```javascript
tieuDeElement.style.color = "blue";         // Đổi màu chữ thành xanh dương
tieuDeElement.style.fontSize = "24px";     // Đổi kích thước font
tieuDeElement.style.border = "1px solid black"; // Thêm viền
// Lưu ý: Cách này chỉ thêm CSS inline. Thường tốt hơn là thêm/xóa class CSS (xem dưới).
```

*   **Thêm/Xóa/Chuyển đổi (Toggle) Class CSS:** Cách này hiệu quả hơn để thay đổi nhiều thuộc tính CSS cùng lúc và tách biệt logic JS với kiểu dáng. Sử dụng thuộc tính `classList`.
    *   `element.classList.add('ten-class')`
    *   `element.classList.remove('ten-class')`
    *   `element.classList.toggle('ten-class')` (thêm class nếu chưa có, xóa nếu đã có)
    *   `element.classList.contains('ten-class')` (kiểm tra xem có class đó không)

    ```javascript
    // Giả sử có CSS: .noiBat { background-color: yellow; font-weight: bold; }
    firstParagraph.classList.add('noiBat'); // Thêm class 'noiBat' vào đoạn văn đầu tiên
    // Để xóa class đó:
    // firstParagraph.classList.remove('noiBat');
    // Để bật/tắt:
    // firstParagraph.classList.toggle('noiBat');
    ```

### 💥 Xử Lý Sự Kiện (Event Handling)

Các "sự kiện" xảy ra khi người dùng tương tác với trang (click chuột, gõ phím, di chuyển chuột...) hoặc khi trạng thái trang thay đổi (tải xong, thay đổi kích thước...). JavaScript có thể "lắng nghe" các sự kiện này và thực thi một khối code (hàm **Event Handler**) khi chúng xảy ra.

Cách phổ biến và hiện đại để gắn trình lắng nghe sự kiện (event listener):

`element.addEventListener('ten_su_kien', function_handler);`

*   `element`: Phần tử DOM mà bạn muốn lắng nghe sự kiện.
*   `'ten_su_kien'`: Tên của sự kiện dưới dạng chuỗi (ví dụ: 'click', 'mouseover', 'submit', 'load', 'keydown').
*   `function_handler`: Một hàm sẽ được thực thi khi sự kiện xảy ra. Hàm này thường nhận một tham số là đối tượng **Event**, chứa thông tin chi tiết về sự kiện.

**Ví dụ (`script.js` tiếp theo):**

```javascript
// Lắng nghe sự kiện click trên nút bấm
buttonElement.addEventListener('click', function(event) {
    // Đoạn code này chạy khi nút được click
    console.log("Nút đã được bấm!");
    // console.log(event); // In ra đối tượng sự kiện với nhiều thông tin hữu ích

    tieuDeElement.textContent = "Bạn vừa bấm nút!"; // Thay đổi nội dung tiêu đề
    buttonElement.style.backgroundColor = 'lightblue'; // Đổi màu nút tạm thời
});

// Lắng nghe sự kiện di chuột qua một đoạn văn
firstParagraph.addEventListener('mouseover', function() {
    firstParagraph.style.color = 'red'; // Đổi màu chữ khi rê chuột qua
});

firstParagraph.addEventListener('mouseout', function() {
    firstParagraph.style.color = 'black'; // Trở lại màu ban đầu khi di chuột ra
});
```
*   Bạn có thể xóa trình lắng nghe sự kiện bằng `removeEventListener('ten_su_kien', function_handler)`. Hàm handler cần phải là cùng một tham chiếu hàm khi bạn thêm vào.

### ⚙️ Cấu Trúc Cơ Bản Khi Làm Việc Với DOM

Thường thì, code JS thao tác DOM nên được đặt SAU khi cấu trúc HTML đã được tạo xong (cuối thẻ `<body>`) hoặc trong một sự kiện lắng nghe khi toàn bộ trang đã tải (`DOMContentLoaded`).

```javascript
document.addEventListener('DOMContentLoaded', function() {
    // Toàn bộ code JS thao tác DOM của bạn nên đặt ở đây
    // Đảm bảo rằng tất cả các phần tử HTML đã có sẵn khi JS chạy

    const myButton = document.getElementById('myButton');
    if (myButton) { // Luôn kiểm tra xem phần tử có tồn tại không
        myButton.addEventListener('click', function() {
            alert("Button clicked!");
        });
    }
});
```

### 🛠 Luyện Tập

*   Tạo một trang HTML đơn giản với một tiêu đề (`<h1>`), một đoạn văn bản (`<p>`), và một nút bấm (`<button>`). Gán ID hoặc class cho các phần tử này.
*   Trong file JS riêng (hoặc trong thẻ `<script>` đặt cuối body), truy cập tiêu đề và đoạn văn bằng ID/Class.
*   Thay đổi nội dung của tiêu đề và đoạn văn.
*   Đổi màu nền và màu chữ của đoạn văn bằng `style`.
*   Tạo một class CSS (ví dụ `.noiBat`) trong file CSS, sau đó dùng JS để `classList.add('noiBat')` cho đoạn văn khi trang tải xong.
*   Thêm trình lắng nghe sự kiện `click` vào nút bấm. Khi nút được click, thay đổi nội dung hoặc kiểu dáng của tiêu đề hoặc đoạn văn.

Thao tác DOM và xử lý sự kiện là kỹ năng cực kỳ thiết yếu để tạo ra các trang web động và phản ứng. Đây mới chỉ là bước khởi đầu!

